"""
genAction.py

Created on 2019-12-23
Updated on 2019-12-23

Copyright Ryan Kan 2019

Description: This is the file which generates the action.
"""

# IMPORTS
from tqdm import trange


# FUNCTIONS
def gen_action(model, observation, no_predictions=500, show_progress_bar=False):
    """
    Generates the action, given a model and the observation array.

    Args:
        model (stable_baselines.A2C): The A2C model. Can be loaded using the `A2C.load()` method.

        observation (np.ndarray): The observation array.

                                  This array would've been generated by a function in the `genObsArray.py`
                                  file.

        no_predictions (int): The number of predictions to be made by the model when generating the action
                              of the model. (Default = 500)

                              For example, if `no_predictions` is 500, then the prediction algorithm would
                              be run 500 times on the SAME observation array. This is to find the best
                              action-amount pair for the current state.

        show_progress_bar (bool): Whether to show the progress bar when generating the action-amount pairs.
                                  (Default = False)

    Returns:
        tuple: The action-amount pair.

               The pair will be in the form (x, y), where x is the action and y is the amount.

    """
    # Generate possible actions
    suggested_actions_count = {"Sell": 0, "Hold": 0, "Buy": 0}  # Tally the number of times each action was suggested
    suggested_amounts = {"Sell": [], "Hold": [], "Buy": []}  # Tally the amount for each action type

    # Run the prediction algorithm `no_predictions` times to see which action (and action amount) appears the most
    if not show_progress_bar:
        iterable = range(no_predictions)
    else:
        iterable = trange(no_predictions, desc="Generating action-amount pairs")

    for _ in iterable:
        action, _ = model.predict([observation])
        suggested_action = action[0]

        if suggested_action[0] == 0:  # Sell
            suggested_actions_count["Sell"] += 1
            suggested_amounts["Sell"].append(suggested_action[1] + 1)

        elif suggested_action[0] == 1:  # Hold
            suggested_actions_count["Hold"] += 1
            suggested_amounts["Hold"].append(suggested_action[1] + 1)

        else:  # Buy
            suggested_actions_count["Buy"] += 1
            suggested_amounts["Buy"].append(suggested_action[1] + 1)

    # Find the mode of the `suggested_actions_count` set
    highest_count = max(list(suggested_actions_count.values()))
    best_action = list(suggested_actions_count.keys())[list(suggested_actions_count.values()).index(highest_count)]

    # Get the mode of the `suggested_amounts` for that action
    possible_amounts = sorted(suggested_amounts[best_action])
    best_amount = max(set(possible_amounts), key=possible_amounts.count)

    return best_action, best_amount
